# CECB-Labs Analysis

![Status](https://img.shields.io/badge/Status-70%25_Completed-success?style=for-the-badge)
![Language](https://img.shields.io/badge/Language-Python-blue?style=for-the-badge&logo=python)
![Category](https://img.shields.io/badge/Category-Cryptography-red?style=for-the-badge&logo=hackthebox)

Detailed analysis and solutions for challenges from [courses.redteamleaders.com](https://courses.redteamleaders.com).

## üèÜ Challenge Progress

| ID | Challenge Name | Status | Solution Path |
|:--:|:---|:---:|:---|
| 01 | **AES-256-GCM (Broken)** | ‚úÖ Done | [`aes256_gcm_bad`](./aes256_gcm_bad) |
| 02 | **Base64 Layers** | ‚úÖ Done | [`base64_layers`](./base64_layers) |
| 03 | **Caesar & Vigenere** | ‚úÖ Done | [`caesar_vigenere`](./caesar_vigenere) |
| 04 | **Diffie-Hellman** | ‚úÖ Done | [`diffie_hellman`](./diffie_hellman) |
| 05 | **Hash Collision** | ‚úÖ Done | [`hash_collision`](./hash_collision) |
| 06 | **RC4** | ‚úÖ Done | [`rc4`](./rc4) |
| 07 | **RSA Decrypt** | ‚úÖ Done | [`rsa_decrypt`](./rsa_decrypt) |
| 08 | **Challenge 8** | ‚¨ú Todo | - |
| 09 | **Challenge 9** | ‚¨ú Todo | - |
| 10 | **Challenge 10** | ‚¨ú Todo | - |

---

## üî¨ Detailed Analysis

<details>
<summary><b>1. AES-256-GCM (Broken)</b></summary>

> **Vulnerability**: The vulnerability stems from **Nonce Reuse** in a stream cipher mode. GCM creates a "keystream" that is combined with your message using XOR. If the same Key and IV are used twice, the same keystream is generated. By XORing two encrypted messages together, the keystream cancels out, leaving just the XOR combination of the two original messages. This makes it easy to recover the original text using basic logic.
>
> **Theoretical Foundation**:
> AES-GCM uses Counter (CTR) mode for encryption, where the ciphertext $C$ is generated by XORing the plaintext $P$ with a keystream $S$ derived from the Key ($K$) and Initialization Vector ($IV$).
> $$S = E_K(IV || Counter)$$
> $$C = P \oplus S$$
> If an $(IV, K)$ pair is reused for two different plaintexts $P_1$ and $P_2$:
> $$C_1 = P_1 \oplus S$$
> $$C_2 = P_2 \oplus S$$
> XORing the two ciphertexts eliminates the unknown keystream:
> $$C_1 \oplus C_2 = (P_1 \oplus S) \oplus (P_2 \oplus S) = P_1 \oplus P_2$$
> This reduces the problem to a "Two-Time Pad" attack, where $P_1 \oplus P_2$ reveals information about both plaintexts.

</details>

<details>
<summary><b>2. Base64 Layers</b></summary>

> **Vulnerability**: This challenge relies on **Encoding** rather than encryption. Base64 represents data using 64 possible characters. The solution involves applying the decoding process repeatedly. Mathematically, it's like peeling layers off an onion: if the message was encoded multiple times, we just keep decoding it layer by layer until the familiar structure of the flag appears.
>
> **Theoretical Foundation**:
> Base64 is a reversible encoding scheme $E: \{0,1\}^* \to \Sigma^*$, where $\Sigma$ is the 64-character alphabet. If a message $M$ is encoded $n$ times:
> $$C = E(E(...E(M)...)) = E^n(M)$$
> The solution finds $M$ by applying the inverse decoding function $D = E^{-1}$ recursively $n$ times:
> $$M = D^n(C) = D(D(...D(C)...))$$
> This is solvable because $D$ is deterministic and requires no secret key.

</details>

<details>
<summary><b>3. Caesar & Vigenere</b></summary>

> **Vulnerability**: Both ciphers work by shifting letters in the alphabet. The Caesar cipher shifts every letter by the same fixed amount (like A->C, B->D). With only 25 possible shifts, it's easy to guess. The Vigen√®re cipher is slightly more complex; it uses a keyword to shift different letters by different amounts based on their position. However, it can still be broken by analyzing letter frequencies or knowing part of the key.
>
> **Theoretical Foundation**:
> **Caesar Cipher**: Defined over the cyclic group $\mathbb{Z}_{26}$. For a shift $k \in \mathbb{Z}_{26}$:
> $$C \equiv (P + k) \pmod{26}$$
> Decryption is $P \equiv (C - k) \pmod{26}$. Security is minimal as $|\mathcal{K}| = 25$.
>
> **Vigen√®re Cipher**: Polyalphabetic substitution using a key vector $\vec{K} = (k_0, k_1, ..., k_{m-1})$ of length $m$.
> $$C_i \equiv (P_i + k_{i \pmod m}) \pmod{26}$$
> This is essentially $m$ interleaved Caesar ciphers, vulnerable to frequency analysis (e.g., Kasiski examination) or known-plaintext attacks if part of $P$ is known.

</details>

<details>
<summary><b>4. Diffie-Hellman</b></summary>

> **Vulnerability**: Diffie-Hellman security relies on the difficulty of finding a "Discrete Logarithm," which means finding the secret exponent used to generate a number. Normally, with very large numbers, this is impossible. However, this challenge uses a very small prime number. This makes the total number of possibilities small enough that a computer can simply test every possible secret number until it finds the one that matches the public key (Brute Force).
>
> **Theoretical Foundation**:
> Diffie-Hellman Key Exchange operations occur in the multiplicative group of integers modulo a prime $p$, denoted $\mathbb{Z}_p^*$.
> Public values: Generator $g$, Prime $p$.
> Private key: $a$. Public key: $A \equiv g^a \pmod p$.
> Security relies on the **Discrete Logarithm Problem (DLP)**: Given $(g, p, A)$, finding $a$ is computationally hard when $p$ is large (e.g., 2048 bits).
> Complexity of best general algorithms (GNFS) is sub-exponential.
> In this challenge, $p$ is small ($p \approx 2^{60}$ or less), allowing algorithms like Pollard's Rho or BSGS to find $a$ in $O(\sqrt{p})$ time, or simple brute force if extremely small.

</details>

<details>
<summary><b>5. Hash Collision</b></summary>

> **Vulnerability**: This exploits the **Birthday Paradox**, which shows that finding two different inputs that produce the same output (a collision) is much easier than you'd expect. For a system with $N$ possibilities, you only need to try about the square root of $N$ times to find a match. The toy hash function here has small enough output size that this "square root" number is very small (around 65,000 tries), making it trivial to break.
>
> **Theoretical Foundation**:
> A hash function $H: \{0,1\}^* \to \{0,1\}^n$ maps arbitrary inputs to $n$-bit digests. The pigeonhole principle guarantees collisions exist since the domain is larger than the co-domain ($2^n$).
> The **Birthday Paradox** states that the probability of finding a collision in a set of $k$ random inputs is approx:
> $$P(collision) \approx 1 - e^{-\frac{k(k-1)}{2N}}, \text{ where } N = 2^n$$
> For $P \approx 0.5$, we need $k \approx \sqrt{2 \ln 2 \cdot N} \approx 1.17\sqrt{N}$.
> For a 32-bit hash ($N=2^{32}$), collision resistance is broken with $k \approx 2^{16}$ operations.

</details>

<details>
<summary><b>6. RC4</b></summary>

> **Vulnerability**: RC4 generates a pseudo-random stream of bytes called a keystream. Encryption is done by XORing the message with this keystream. The critical failure here is **Key Reuse**. If the same keystream is used to encrypt two different messages, XORing the two ciphertexts together cancels out the keystream entirely. This leaves you with the two plaintexts mixed together, which can be easily separated.
>
> **Theoretical Foundation**:
> RC4 functions as a stream cipher generating a keystream $K(t)$ from a state permutation $S$.
> $$C_i = P_i \oplus K_i$$
> Reusing the same state (same key/IV) produces the identical keystream sequence $K$.
> $$C^{(1)} = P^{(1)} \oplus K$$
> $$C^{(2)} = P^{(2)} \oplus K$$
> $$C^{(1)} \oplus C^{(2)} = (P^{(1)} \oplus K) \oplus (P^{(2)} \oplus K) = P^{(1)} \oplus P^{(2)}$$
> This allows recovery of $P^{(2)}$ if $P^{(1)}$ is known: $P^{(2)} = C^{(1)} \oplus C^{(2)} \oplus P^{(1)}$.

</details>

<details>
<summary><b>7. RSA Decrypt</b></summary>

> **Vulnerability**: RSA relies on the fact that multiplying two large primes ($p$ and $q$) is easy, but factoring their product $N$ back into $p$ and $q$ is hard. However, if $p$ and $q$ are very close to each other in value, unique factorization methods like **Fermat‚Äôs Factorization** become extremely fast. It works by checking numbers near the square root of $N$, allowing us to find the factors almost instantly.
>
> **Theoretical Foundation**:
> RSA security depends on the **Integer Factorization Problem** of $N = pq$.
> **Fermat's Factorization** is based on representing $N$ as a difference of squares:
> $$N = A^2 - B^2 = (A-B)(A+B)$$
> where $A = \frac{p+q}{2}$ and $B = \frac{p-q}{2}$.
> If $|p-q|$ is small ($p \approx q \approx \sqrt{N}$), then $B$ is small, and $A$ is slightly larger than $\sqrt{N}$.
> We search for $A$ starting at $\lceil\sqrt{N}\rceil$ and check if $A^2 - N$ is a perfect square ($B^2$).
> This succeeds in $O(|p-q|)$ steps, vastly faster than general purpose factoring for this special case.

</details>
